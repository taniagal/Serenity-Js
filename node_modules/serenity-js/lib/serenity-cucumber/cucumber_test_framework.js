"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var attempt_require_1 = require("@serenity-js/core/lib/io/attempt_require");
var _ = require("lodash");
var glob = require("glob");
var path = require("path");
var CucumberTestFramework = (function () {
    function CucumberTestFramework(requireRoot, config) {
        this.requireRoot = requireRoot;
        this.args = [];
        this.serenityCucumberModule = function () { return glob.sync(path.resolve(__dirname, '../serenity-cucumber') + '/index.?s').pop(); };
        this.stageCue = function () { return glob.sync(path.resolve(__dirname, '../serenity-cucumber') + '/stage_cue.?s').pop(); };
        this.args = ['node', 'cucumberjs'].
            concat(['--require', this.serenityCucumberModule()]).
            concat(['--require', this.stageCue()]).
            concat(this.argumentsFrom(config));
    }
    CucumberTestFramework.prototype.run = function (specs) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var Cucumber = attempt_require_1.attemptToRequire('cucumber');
            Cucumber.Cli(_this.args.concat(specs)).run(function (wasSuccessful) {
                if (wasSuccessful) {
                    resolve(wasSuccessful);
                }
                else {
                    reject(new Error('Cucumber test run has failed.'));
                }
            });
        });
    };
    CucumberTestFramework.prototype.argumentsFrom = function (config) {
        var _this = this;
        var resolveGlobs = function (path) { return glob.sync(path, { cwd: _this.requireRoot }); };
        var resolvePaths = function (globPath) { return _.chain(globPath).map(resolveGlobs).flatten().value(); };
        var resolvedConfig = Object.assign({}, config, { require: resolvePaths(config.require || []) });
        var cleanUpFlags = function (option) {
            switch (option[1]) {
                case 'true': return [option[0]];
                case 'false': return [option[0], false];
                default: return option;
            }
        };
        var onlyApplicableOptions = function (option) { return option[1] !== false; };
        return _.chain(resolvedConfig).toPairs().
            flatMap(function (option) { return _.castArray(option[1]).map(function (param) { return ["--" + option[0], param]; }); }).
            map(cleanUpFlags).filter(onlyApplicableOptions).
            flatten().
            value();
    };
    return CucumberTestFramework;
}());
exports.CucumberTestFramework = CucumberTestFramework;
//# sourceMappingURL=cucumber_test_framework.js.map