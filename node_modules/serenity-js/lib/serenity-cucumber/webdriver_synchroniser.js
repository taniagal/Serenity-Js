"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("@serenity-js/core/lib/recording/async");
var withArityOf = require("util-arity");
var isGenerator = require('is-generator'); // tslint:disable-line:no-var-requires - JS module with no typings
var co = require('co'); // tslint:disable-line:no-var-requires - JS module with no typings
/**
 * Monkey-patches Cucumber.js Given/When/Then step generators to ensure that any step definition they create
 * is executed within WebDriver's ControlFlow and therefore synchronised with it
 *
 * @param cucumber
 * @param controlFlow
 */
function synchronise(cucumber, controlFlow) {
    [
        'Given',
        'When',
        'Then',
    ]
        .forEach(function (stepGenerator) { return cucumber[stepGenerator] = synchronising(cucumber[stepGenerator]); });
    // ---
    /**
     * Creates a synchronising StepGenerator, which looks like a regular StepGenerator but with this significant
     * difference, that any step function passed to it will be wrapped and executed in the context of WebDriver
     * Control Flow
     *
     * @param originalStepGenerator
     * @return {StepGenerator}
     */
    function synchronising(originalStepGenerator) {
        function synchronisingStepGenerator(pattern, options, code) {
            var originalStep = code || options, synchronised = mimicArity(originalStep, synchronisedStep(originalStep));
            var params = !!code
                ? [pattern, options, synchronised]
                : [pattern, synchronised];
            return originalStepGenerator.apply(cucumber, params);
        }
        return mimicArity(originalStepGenerator, synchronisingStepGenerator);
    }
    /**
     * Provides a synchronised wrapper around the user-defined step
     *
     * @param originalStep
     * @return {(...args:any[])=>(Promise<void> | void)}
     */
    function synchronisedStep(originalStep) {
        return mimicInterface(originalStep, function stepWrapper() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var deferred = new async_1.Deferred(), context = this;
            if (isGenerator.fn(originalStep)) {
                originalStep = co.wrap(originalStep);
            }
            controlFlow
                .execute(function () { return originalStep.apply(context, args); })
                .then(deferred.resolve, deferred.reject);
            return deferred.promise;
        });
    }
}
exports.synchronise = synchronise;
/**
 * Assumes that step definition has a callback interface if the number of parameters passed by cucumber
 * matches its signature
 *
 * @return boolean
 * @param step
 * @param params
 */
function hasCallbackInterface(step, params) {
    return step.length === params.length;
}
/**
 * Makes the pretender function conform to original function interface (i.e. callback- or promise-based)
 *
 * @param original
 * @param pretender
 * @return {StepDefinition}
 */
function mimicInterface(original, pretender) {
    return function stepWrapper() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this, result = pretender.apply(context, args);
        if (!hasCallbackInterface(original, args)) {
            return result;
        }
    };
}
/**
 * Makes the pretender function of the same arity as the original one to deceive cucumber.
 *
 * @param original
 * @param pretender
 * @return {(...args:any[])=>any}
 */
function mimicArity(original, pretender) {
    return withArityOf(original.length, pretender);
}
//# sourceMappingURL=webdriver_synchroniser.js.map