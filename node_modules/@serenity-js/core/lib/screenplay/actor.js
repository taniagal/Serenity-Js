"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var domain_1 = require("../domain");
var activity_description_1 = require("../recording/activity_description");
var StackTrace = require("stacktrace-js");
var Actor = (function () {
    function Actor(name, stage_manager) {
        this.name = name;
        this.abilities = {};
        this.tracker = new ActivityTracker(stage_manager);
    }
    Actor.named = function (name) {
        return new Actor(name, __1.serenity.stageManager());
    };
    Actor.prototype.whoCan = function () {
        var _this = this;
        var abilities = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            abilities[_i] = arguments[_i];
        }
        abilities.forEach(function (ability) {
            _this.abilities[ability.constructor.name] = ability;
        });
        return this;
    };
    Actor.prototype.abilityTo = function (doSomething) {
        if (!this.can(doSomething)) {
            throw new Error("I don't have the ability to " + doSomething.name + ", said " + this + " sadly.");
        }
        return this.abilities[doSomething.name];
    };
    Actor.prototype.attemptsTo = function () {
        var _this = this;
        var activities = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            activities[_i] = arguments[_i];
        }
        return activities.map(this.tracker.track).reduce(function (previous, current) {
            return previous.then(function () { return current.performAs(_this); });
        }, Promise.resolve(null));
    };
    Actor.prototype.toSee = function (question) {
        return question.answeredBy(this);
    };
    Actor.prototype.toString = function () {
        return this.name;
    };
    Actor.prototype.can = function (doSomething) {
        return !!this.abilities[doSomething.name];
    };
    return Actor;
}());
exports.Actor = Actor;
var ActivityTracker = (function () {
    function ActivityTracker(stage_manager) {
        var _this = this;
        this.stage_manager = stage_manager;
        this.track = function (activity) { return _this.shouldTrack(activity) ? new TrackedActivity(activity, _this.stage_manager) : activity; };
        this.shouldTrack = function (activity) { return activity.toString() !== '[object Object]'; };
    }
    return ActivityTracker;
}());
var TrackedActivity = (function () {
    function TrackedActivity(activity, stage_manager) {
        this.activity = activity;
        this.stage_manager = stage_manager;
        this.location = locateCallerOf('Actor.attemptsTo');
    }
    TrackedActivity.prototype.performAs = function (actor) {
        var _this = this;
        var description = activity_description_1.describeAs(this.activity.toString(), actor);
        return this.location.then(function (location) {
            var recorded_activity = new domain_1.RecordedActivity(description, location);
            return Promise.resolve()
                .then(function () { return _this.beforeStep(recorded_activity); })
                .then(function () { return _this.activity.performAs(actor); })
                .then(function () { return _this.afterStep(recorded_activity); }, function (e) { return _this.onFailure(recorded_activity, e); });
        });
    };
    TrackedActivity.prototype.beforeStep = function (activity) {
        this.stage_manager.notifyOf(new domain_1.ActivityStarts(activity));
    };
    TrackedActivity.prototype.afterStep = function (activity) {
        this.stage_manager.notifyOf(new domain_1.ActivityFinished(new domain_1.Outcome(activity, domain_1.Result.SUCCESS)));
    };
    TrackedActivity.prototype.onFailure = function (activity, error) {
        this.stage_manager.notifyOf(new domain_1.ActivityFinished(new domain_1.Outcome(activity, this.resultFrom(error), error)));
        return Promise.reject(error);
    };
    // todo: extract
    TrackedActivity.prototype.resultFrom = function (error) {
        var constructorOf = function (e) { return e && e.constructor ? e.constructor.name : ''; };
        // todo: sniff the exception to find out about the Result. Did the test fail, or was it compromised?
        return /AssertionError/.test(constructorOf(error))
            ? domain_1.Result.FAILURE
            : domain_1.Result.ERROR;
    };
    return TrackedActivity;
}());
// todo: extract
function locateCallerOf(method) {
    var origin_of = function (frames) { return frames.findIndex(function (frame) { return !!frame.functionName && !!~frame.functionName.indexOf(method); }); };
    var get_frame = function (frames) { return frames[origin_of(frames) + 1]; };
    var frames_of_interest = function (frame) { return frame && frame.fileName && !~frame.fileName.indexOf('node_modules'); };
    var to_location = function (frame) { return (frame && {
        path: frame.fileName,
        line: frame.lineNumber,
        column: frame.columnNumber,
    }); };
    return StackTrace.get({ filter: frames_of_interest }).then(get_frame).then(to_location);
}
//# sourceMappingURL=actor.js.map