export declare enum Result {
    /**
     * Failures due to external events or systems that compromise the validity of the test.
     */
    COMPROMISED = 1,
    /**
     * Failure, due to some other exception.
     */
    ERROR = 2,
    /**
     * Failure, due to an assertion error
     * For a test case, this means one of the tests in the test case failed.
     */
    FAILURE = 4,
    /**
     * The test step was not executed because a previous step in this test case failed.
     * A whole test case can be skipped using tags or annotations to indicate that it is currently "work-in-progress"
     */
    SKIPPED = 8,
    /**
     * The test or test case was deliberately ignored.
     * Tests can be ignored via the @Ignore annotation in JUnit, for example.
     * Ignored tests are not considered the same as pending tests: a pending test is one that
     * has been specified, but the corresponding code is yet to be implemented, whereas an
     * ignored test can be a temporarily-deactivated test (during refactoring, for example).
     */
    IGNORED = 16,
    /**
     * A pending test is one that has been specified but not yet implemented.
     * In a JUnit test case, you can use the (Thucydides) @Pending annotation to mark this.
     * A pending test case is a test case that has at least one pending test.
     */
    PENDING = 32,
    /**
     * The test or test case ran as expected.
     */
    SUCCESS = 64,
    Failed = 7,
    Finished = 71,
}
export interface Identifiable {
    id: string;
}
export declare class Tag {
    type: string;
    values: string[];
    private static Pattern;
    static from(text: string): Tag;
    constructor(type: string, values?: string[]);
    readonly value: string;
}
export declare class RecordedScene implements Identifiable {
    name: string;
    category: string;
    location: SourceLocation;
    tags: Tag[];
    id: string;
    constructor(name: string, category: string, location?: SourceLocation, tags?: Tag[], id?: string);
    equals(another: RecordedScene): boolean;
    toString(): string;
}
export interface SourceLocation {
    path: string;
    line?: number;
    column?: number;
}
export declare class UnknownSourceLocation implements SourceLocation {
    path: any;
    line: any;
    column: any;
}
export declare class RecordedActivity implements Identifiable {
    name: string;
    location: SourceLocation;
    id: string;
    constructor(name: string, location?: SourceLocation, id?: string);
    equals(another: RecordedActivity): boolean;
    toString(): string;
}
export declare class Outcome<T> {
    subject: T;
    result: Result;
    error: Error;
    constructor(subject: T, result: Result, error?: Error);
    toString(): string;
}
export declare class Photo {
    path: string;
    constructor(path: string);
}
export declare class PhotoReceipt {
    activity: RecordedActivity;
    photo: PromiseLike<Photo>;
    constructor(activity: RecordedActivity, photo: PromiseLike<Photo>);
    toString(): string;
}
