"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Result;
(function (Result) {
    /**
     * Failures due to external events or systems that compromise the validity of the test.
     */
    Result[Result["COMPROMISED"] = 1] = "COMPROMISED";
    /**
     * Failure, due to some other exception.
     */
    Result[Result["ERROR"] = 2] = "ERROR";
    /**
     * Failure, due to an assertion error
     * For a test case, this means one of the tests in the test case failed.
     */
    Result[Result["FAILURE"] = 4] = "FAILURE";
    /**
     * The test step was not executed because a previous step in this test case failed.
     * A whole test case can be skipped using tags or annotations to indicate that it is currently "work-in-progress"
     */
    Result[Result["SKIPPED"] = 8] = "SKIPPED";
    /**
     * The test or test case was deliberately ignored.
     * Tests can be ignored via the @Ignore annotation in JUnit, for example.
     * Ignored tests are not considered the same as pending tests: a pending test is one that
     * has been specified, but the corresponding code is yet to be implemented, whereas an
     * ignored test can be a temporarily-deactivated test (during refactoring, for example).
     */
    Result[Result["IGNORED"] = 16] = "IGNORED";
    /**
     * A pending test is one that has been specified but not yet implemented.
     * In a JUnit test case, you can use the (Thucydides) @Pending annotation to mark this.
     * A pending test case is a test case that has at least one pending test.
     */
    Result[Result["PENDING"] = 32] = "PENDING";
    /**
     * The test or test case ran as expected.
     */
    Result[Result["SUCCESS"] = 64] = "SUCCESS";
    Result[Result["Failed"] = 7] = "Failed";
    Result[Result["Finished"] = 71] = "Finished";
})(Result = exports.Result || (exports.Result = {}));
var Tag = (function () {
    function Tag(type, values) {
        if (values === void 0) { values = []; }
        this.type = type;
        this.values = values;
    }
    Tag.from = function (text) {
        var _a = Tag.Pattern.exec(text), type = _a[1], values = _a[2];
        return new Tag(type, values.split(',').filter(function (_) { return _.length > 0; }).map(function (_) { return _.trim(); }));
    };
    Object.defineProperty(Tag.prototype, "value", {
        get: function () {
            return this.values.join(', ');
        },
        enumerable: true,
        configurable: true
    });
    return Tag;
}());
Tag.Pattern = /^@([\w-]+)[:\s]?(.*)/i;
exports.Tag = Tag;
var RecordedScene = (function () {
    function RecordedScene(name, category, location, tags, id) {
        if (location === void 0) { location = new UnknownSourceLocation(); }
        if (tags === void 0) { tags = []; }
        if (id === void 0) { id = category + ":" + name; }
        this.name = name;
        this.category = category;
        this.location = location;
        this.tags = tags;
        this.id = id;
    }
    RecordedScene.prototype.equals = function (another) {
        return (another instanceof RecordedScene) &&
            this.name === another.name &&
            this.category === another.category &&
            this.location.path === another.location.path &&
            this.location.line === another.location.line &&
            this.location.column === another.location.column;
        // todo: tags are _probably_ not necessary ?
    };
    RecordedScene.prototype.toString = function () {
        return this.name +
            (" (category: " + this.category + ", path: " + this.location.path) +
            when(!!this.location.line, ':' + this.location.line) +
            when(!!this.location.column, ':' + this.location.column) +
            (when(this.id !== this.name, ', id: ' + this.id) + ")");
    };
    return RecordedScene;
}());
exports.RecordedScene = RecordedScene;
var UnknownSourceLocation = (function () {
    function UnknownSourceLocation() {
        this.path = undefined;
        this.line = undefined;
        this.column = undefined;
    }
    return UnknownSourceLocation;
}());
exports.UnknownSourceLocation = UnknownSourceLocation;
var RecordedActivity = (function () {
    function RecordedActivity(name, location, id) {
        if (location === void 0) { location = new UnknownSourceLocation(); }
        if (id === void 0) { id = name; }
        this.name = name;
        this.location = location;
        this.id = id;
    }
    RecordedActivity.prototype.equals = function (another) {
        return (another instanceof RecordedActivity) &&
            this.name === another.name &&
            this.location.path === another.location.path &&
            this.location.line === another.location.line &&
            this.location.column === another.location.column &&
            this.id === another.id;
    };
    RecordedActivity.prototype.toString = function () {
        return "" + this.name + when(this.id !== this.name, ' (id: ' + this.id + ')');
    };
    return RecordedActivity;
}());
exports.RecordedActivity = RecordedActivity;
var Outcome = (function () {
    function Outcome(subject, result, error) {
        this.subject = subject;
        this.result = result;
        this.error = error;
    }
    Outcome.prototype.toString = function () {
        return this.subject.toString() + " (result: " + Result[this.result] + when(!!this.error, ', error:' + this.error) + ")";
    };
    return Outcome;
}());
exports.Outcome = Outcome;
var Photo = (function () {
    function Photo(path) {
        this.path = path;
    }
    return Photo;
}());
exports.Photo = Photo;
var PhotoReceipt = (function () {
    function PhotoReceipt(activity, photo) {
        this.activity = activity;
        this.photo = photo;
    }
    PhotoReceipt.prototype.toString = function () {
        return this.activity.toString();
    };
    return PhotoReceipt;
}());
exports.PhotoReceipt = PhotoReceipt;
function when(condition, value) {
    return condition ? value : '';
}
//# sourceMappingURL=model.js.map