"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var domain_1 = require("../domain");
var RehearsalReport = (function () {
    function RehearsalReport() {
    }
    RehearsalReport.from = function (events) {
        var previousNode;
        var currentNode;
        var currentScene;
        return events.reduce(function (fullReport, event) {
            switch (event.constructor) {
                case domain_1.SceneStarts:
                    currentScene = fullReport.append(new ScenePeriod(event));
                    currentNode = currentScene;
                    break;
                case domain_1.ActivityStarts:
                    currentNode = currentNode.append(new ActivityPeriod(event));
                    break;
                case domain_1.SceneFinished:
                    currentNode = currentNode.concludeWith(event);
                    break;
                case domain_1.ActivityFinished:
                    // The Photographer triggers a PhotoAttempted event after the ActivityFinished,
                    // that's why we need to cache both the previous and the current node
                    previousNode = currentNode;
                    currentNode = currentNode.concludeWith(event);
                    break;
                case domain_1.SceneTagged:
                    currentScene.tagWithPromised(event.value);
                    break;
                case domain_1.PhotoAttempted:
                    [previousNode, currentNode]
                        .filter(function (node) { return !!node && node.matches(event.value.activity); })
                        .forEach(function (node) { return node.attach(event.value.photo); });
                    break;
            }
            return fullReport;
        }, new RehearsalPeriod());
    };
    return RehearsalReport;
}());
exports.RehearsalReport = RehearsalReport;
var ReportPeriod = (function () {
    function ReportPeriod(start) {
        this.children = [];
        this.promisedPhotos = [];
        this.value = start.value;
        this.startedAt = start.timestamp;
    }
    ReportPeriod.prototype.concludeWith = function (finished) {
        this.finishedAt = finished.timestamp;
        this.outcome = finished.value;
        if (!this.parent) {
            return this;
        }
        return this.matches(finished.value.subject)
            ? this.parent
            : this.parent.concludeWith(finished);
    };
    ReportPeriod.prototype.attach = function (promisedPhoto) {
        this.promisedPhotos.push(promisedPhoto);
    };
    ReportPeriod.prototype.photos = function () {
        // todo: maybe use some constant rather than a blunt "undefined"?
        return Promise.all(this.promisedPhotos).then(function (photos) { return photos.filter(function (p) { return p !== undefined; }); });
    };
    ReportPeriod.prototype.duration = function () {
        return this.finishedAt - this.startedAt;
    };
    ReportPeriod.prototype.append = function (child) {
        child.parent = this;
        this.children.push(child);
        return child;
    };
    return ReportPeriod;
}());
exports.ReportPeriod = ReportPeriod;
var RehearsalPeriod = (function (_super) {
    __extends(RehearsalPeriod, _super);
    function RehearsalPeriod() {
        var _this = _super.call(this, new domain_1.DomainEvent(new Rehearsal())) || this;
        _this.parent = undefined;
        return _this;
    }
    RehearsalPeriod.prototype.matches = function (finished) {
        return false;
    };
    RehearsalPeriod.prototype.exportedUsing = function (exporter) {
        return exporter.exportRehearsal(this);
    };
    return RehearsalPeriod;
}(ReportPeriod));
exports.RehearsalPeriod = RehearsalPeriod;
var Rehearsal = (function () {
    function Rehearsal() {
    }
    return Rehearsal;
}());
exports.Rehearsal = Rehearsal;
var ActivityPeriod = (function (_super) {
    __extends(ActivityPeriod, _super);
    function ActivityPeriod() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ActivityPeriod.prototype.matches = function (another) {
        return this.value.equals(another);
    };
    ActivityPeriod.prototype.exportedUsing = function (exporter) {
        return exporter.exportActivity(this);
    };
    return ActivityPeriod;
}(ReportPeriod));
exports.ActivityPeriod = ActivityPeriod;
var ScenePeriod = (function (_super) {
    __extends(ScenePeriod, _super);
    function ScenePeriod() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tags = [];
        return _this;
    }
    ScenePeriod.prototype.matches = function (another) {
        return this.value.equals(another);
    };
    ScenePeriod.prototype.exportedUsing = function (exporter) {
        return exporter.exportScene(this);
    };
    ScenePeriod.prototype.tagWithPromised = function (tag) {
        this.tags.push(tag);
    };
    ScenePeriod.prototype.promisedTags = function () {
        return Promise.all(this.tags);
    };
    return ScenePeriod;
}(ReportPeriod));
exports.ScenePeriod = ScenePeriod;
//# sourceMappingURL=rehearsal_report.js.map